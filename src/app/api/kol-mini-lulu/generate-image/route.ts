import { NextRequest, NextResponse } from 'next/server';
import { GoogleGenAI } from "@google/genai";
import { checkRateLimit, getClientIp, rateLimitResponse, RATE_LIMITS } from '@/lib/rateLimit';

export async function POST(request: NextRequest) {
    // Rate limiting
    const clientIp = getClientIp(request);
    const rateCheck = checkRateLimit(`kol-mini-lulu-image:${clientIp}`, RATE_LIMITS.kolGeneration);
    if (!rateCheck.allowed) {
        return rateLimitResponse(rateCheck);
    }

    try {
        const body = await request.json();
        const { prompt, character, customPrompt, apiKey } = body;

        if (!prompt) {
            return NextResponse.json(
                { error: 'Missing prompt' },
                { status: 400 }
            );
        }

        // Initialize Gemini
        const genAI = new GoogleGenAI({
            apiKey: apiKey || process.env.GEMINI_API_KEY || process.env.NEXT_PUBLIC_GEMINI_API_KEY || ""
        });

        // Build character description
        const charDesc = character === 'both'
            ? 'A cute grey British Shorthair Cat named Mini (with amber eyes, chubby, grumpy-cute expression) AND a golden Golden Retriever Dog named Lulu (happy smile, tongue out, fluffy)'
            : character === 'mini'
                ? 'A cute grey British Shorthair Cat named Mini (amber eyes, chubby, grumpy-cute expression, red bow tie)'
                : 'A golden Golden Retriever Dog named Lulu (happy smile, tongue out, fluffy, blue scarf)';

        // Construct a highly detailed prompt for 3D Pixar style
        const basePrompt = `
        Create a 3D Pixar/Disney-style animation scene. High quality, vibrant colors, expressive lighting.
        
        Character(s): ${charDesc}.
        ${customPrompt ? `Character context: ${customPrompt}.` : ''}
        
        Scene: ${prompt}
        
        Style: 3D render, Pixar animation quality, Octane render, 8K, highly detailed, cinematic lighting.
        Aspect Ratio: 9:16 (Vertical, portrait orientation).
        Background: Rich, detailed environment matching the scene.
        `;

        // Try primary model: gemini-2.0-flash-preview-image-generation
        try {
            const imageResponse = await genAI.models.generateContent({
                model: 'gemini-3-pro-image-preview',
                contents: [{ role: 'user', parts: [{ text: basePrompt }] }],
                config: {
                    responseModalities: ['image'],
                }
            });

            const candidates = imageResponse.candidates;
            const parts = candidates?.[0]?.content?.parts;
            const imagePart = parts?.find((p: any) => p.inlineData);

            if (imagePart && imagePart.inlineData) {
                const base64 = imagePart.inlineData.data;
                const mimeType = imagePart.inlineData.mimeType || 'image/png';
                return NextResponse.json({ result: `data:${mimeType};base64,${base64}` });
            }

            throw new Error("No image generated by primary model");

        } catch (primaryError) {
            console.warn("gemini-3-pro-image-preview failed, trying gemini-2.0-flash:", primaryError);

            // Try fallback model: gemini-2.0-flash-preview-image-generation
            try {
                const fallbackResponse = await genAI.models.generateContent({
                    model: 'gemini-2.0-flash-preview-image-generation',
                    contents: [{ role: 'user', parts: [{ text: basePrompt }] }],
                    config: {
                        responseModalities: ['image', 'text'],
                    }
                });

                const parts = fallbackResponse.candidates?.[0]?.content?.parts;
                const imagePart = parts?.find((p: any) => p.inlineData);

                if (imagePart && imagePart.inlineData) {
                    const base64 = imagePart.inlineData.data;
                    const mimeType = imagePart.inlineData.mimeType || 'image/png';
                    return NextResponse.json({ result: `data:${mimeType};base64,${base64}` });
                }

                throw new Error("No image generated by fallback model");

            } catch (fallbackError) {
                console.warn("Fallback model also failed, using Pollinations:", fallbackError);

                // Final fallback: Pollinations.ai
                const safePrompt = encodeURIComponent(basePrompt.slice(0, 300));
                const seed = Math.floor(Math.random() * 100000);
                const imageUrl = `https://image.pollinations.ai/prompt/${safePrompt}?width=576&height=1024&model=flux&seed=${seed}&nologo=true`;

                return NextResponse.json({ result: imageUrl });
            }
        }

    } catch (error) {
        console.error('KOL Mini Lulu Image API Error:', error);
        return NextResponse.json(
            { error: error instanceof Error ? error.message : 'Unknown error' },
            { status: 500 }
        );
    }
}
